<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CS 526 – Graphical Perception Study Report</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,wght@0,400;0,600;0,700;1,400&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #fafaf8;
  --text: #1a1a1a;
  --muted: #6b6b6b;
  --accent: #2563eb;
  --accent2: #7c3aed;
  --border: #e5e5e3;
  --card: #ffffff;
  --serif: 'Source Serif 4', Georgia, serif;
  --sans: 'DM Sans', system-ui, sans-serif;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: var(--sans);
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  font-size: 16px;
}
.container { max-width: 960px; margin: 0 auto; padding: 0 24px; }

header {
  border-bottom: 1px solid var(--border);
  padding: 48px 0 40px;
  margin-bottom: 48px;
}
header .label {
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--accent);
  margin-bottom: 12px;
}
header h1 {
  font-family: var(--serif);
  font-size: 42px;
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: 12px;
}
header .subtitle {
  font-size: 18px;
  color: var(--muted);
  max-width: 700px;
}
header .meta {
  margin-top: 20px;
  font-size: 14px;
  color: var(--muted);
}

section { margin-bottom: 56px; }
section h2 {
  font-family: var(--serif);
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 16px;
  padding-bottom: 8px;
  border-bottom: 2px solid var(--text);
  display: inline-block;
}
section h3 {
  font-family: var(--serif);
  font-size: 20px;
  font-weight: 600;
  margin: 24px 0 10px;
}
section p {
  margin-bottom: 14px;
  max-width: 720px;
}
section ul, section ol {
  margin: 0 0 14px 24px;
  max-width: 720px;
}
section li { margin-bottom: 6px; }

.chart-container {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 32px;
  margin: 24px 0;
  overflow-x: auto;
}
.chart-title {
  font-family: var(--serif);
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 4px;
}
.chart-subtitle {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 20px;
}

.tooltip {
  position: absolute;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 14px;
  border-radius: 6px;
  font-size: 13px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  z-index: 100;
  line-height: 1.5;
}

.stats-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
  margin: 16px 0;
}
.stats-table th {
  text-align: left;
  padding: 10px 12px;
  border-bottom: 2px solid var(--text);
  font-weight: 600;
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.stats-table td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
}
.stats-table tr:hover td { background: #f5f5f3; }

.legend { display: flex; gap: 24px; margin: 12px 0; font-size: 13px; flex-wrap: wrap; }
.legend-item { display: flex; align-items: center; gap: 6px; }
.legend-swatch { width: 14px; height: 14px; border-radius: 3px; }

footer {
  border-top: 1px solid var(--border);
  padding: 32px 0;
  margin-top: 48px;
  font-size: 14px;
  color: var(--muted);
}

a { color: var(--accent); }
strong { font-weight: 600; }

.highlight-box {
  background: #f0f4ff;
  border-left: 4px solid var(--accent);
  padding: 16px 20px;
  border-radius: 0 6px 6px 0;
  margin: 20px 0;
  font-size: 15px;
}

.warning-box {
  background: #fffbeb;
  border-left: 4px solid #f59e0b;
  padding: 14px 18px;
  border-radius: 0 6px 6px 0;
  margin: 16px 0;
  font-size: 14px;
  color: #92400e;
}
</style>
</head>
<body>

<div class="container">
<header>
  <div class="label">CS 526 – Project 1</div>
  <h1>Graphical Perception: A Replication and Extension Study</h1>
  <p class="subtitle">Evaluating how accurately people interpret values across eight visualization types, replicating Cleveland &amp; McGill's foundational work and extending it with novel encodings.</p>
  <p class="meta">Harsh Jain · February 2026 · <a href="https://harshjain5903.github.io/graphical-perception-study/experiment.html" target="_blank">Try the Experiment →</a></p>
</header>

<!-- INTRODUCTION -->
<section id="introduction">
  <h2>Introduction</h2>
  <p>How accurately can people read data from different types of charts? This fundamental question underpins all of data visualization design. In their landmark 1984 study, Cleveland and McGill established a hierarchy of graphical perception—showing that some visual encodings (like position on a common scale) allow far more accurate judgments than others (like area or angle).</p>
  <p>This study replicates and extends that foundational work. We tested <strong>12 participants</strong> across <strong>8 visualization types</strong> (4 from prior literature and 4 novel designs), collecting <strong>672 total judgments</strong>. Each participant estimated the percentage of the smaller highlighted value relative to the larger one across 56 randomized trials. Our goals were to: (1) verify whether Cleveland and McGill's ranking holds with a new participant pool, and (2) evaluate four novel encoding types—radial bars, color saturation, donut charts, and star glyphs—that were not part of the original studies.</p>
</section>

<!-- BACKGROUND -->
<section id="background">
  <h2>Background</h2>
  <p>Cleveland and McGill (1984) proposed a theoretical ranking of elementary perceptual tasks, from most to least accurate: position along a common scale, position on non-aligned scales, length, direction/angle, area, volume, curvature, and shading/color saturation. They validated this ranking through controlled experiments where participants judged the ratio between two highlighted values in various chart types.</p>
  <p>Heer and Bostock (2010) replicated this work using Amazon Mechanical Turk, confirming the original findings with crowdsourced participants and extending the study to include area-based encodings such as circles and rectangles (treemaps). Their results largely supported Cleveland and McGill's hierarchy, with position-based encodings outperforming area and angle-based alternatives.</p>

  <p>Our study builds on this body of work by evaluating four encodings from the original literature—aligned bars, stacked bars, pie charts, and circle area—alongside four novel designs: radial bars (position on a circular axis), color saturation, donut charts, and star glyphs (irregular area encodings).</p>
</section>

<!-- METHODS -->
<section id="methods">
  <h2>Methods</h2>

  <h3>Visualization Types</h3>
  <p>We evaluated eight visualization designs, split into two categories:</p>
  <p><strong>From prior literature (4 types):</strong> Aligned Bars (position on a common scale — vertical bars sharing a common baseline), Stacked Bars (position on non-aligned scales — participants compare the lengths of two highlighted segments within a single stacked bar), Pie Chart (angle encoding), and Circle Area (area encoding).</p>
  <p><strong>Novel designs (4 types):</strong> Radial Bars (position along a circular axis, where bar length is encoded as radius rather than height), Color Saturation (darkness-based encoding — participants compare the darkness of two highlighted rectangles), Donut Chart (angle with an inner radius), and Star Glyphs (irregular-shape area encoding — participants compare the filled area of two highlighted stars).</p>

  <h3>Experimental Design</h3>
  <p>The experiment was organized into 8 blocks (one per visualization type), each containing 7 trials. Trials within each block used the ground-truth ratios of 14%, 25%, 38%, 50%, 62%, 75%, and 86%, consistent with the ratios used by Cleveland and McGill. The order of blocks was randomized for each participant to reduce learning effects. Each stimulus included distractor data marks to provide context, with the two target values clearly outlined in red.</p>

  <h3>Participants &amp; Procedure</h3>
  <p>We recruited 12 participants (friends, family, and classmates). The experiment was hosted as a web page built with D3.js. Participants viewed one stimulus at a time, used a slider to enter their percentage estimate (0–100%), and clicked "Next" to advance. Response time was recorded automatically. The total experiment took approximately 10–15 minutes per participant. Data was downloaded as a CSV file at the end.</p>

  <h3>Error Metric</h3>
  <p>Following Cleveland and McGill, we computed the log-absolute error for each trial: <strong>log<sub>2</sub>(|response − true| + ⅛)</strong>. This transformation reduces the influence of extreme outliers and compresses the scale. We then computed the mean log-error, standard error, and 95% confidence interval (mean ± 1.96 × SE) for each visualization type.</p>
</section>

<!-- RESULTS -->
<section id="results">
  <h2>Results</h2>

  <p>The figure below shows the mean log-absolute error for each visualization type, ranked from best (lowest error) to worst. Error bars represent 95% confidence intervals. All summary statistics were computed directly from the collected experimental data (672 trials across 12 participants).</p>

  <div class="chart-container">
    <div class="chart-title">Mean Log-Absolute Error by Visualization Type</div>
    <div class="chart-subtitle">Lower is better · Error bars show 95% CI · n = 84 trials per type (12 participants × 7 trials)</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:#2563eb"></div> From prior literature</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#7c3aed"></div> Novel designs (ours)</div>
    </div>
    <div id="chart-log-error"></div>
  </div>

  <p>Aligned bars produced the lowest error (mean log-error = 1.90), consistent with Cleveland and McGill's finding that position on a common scale is the most accurate perceptual encoding. Among our novel designs, color saturation performed surprisingly well (2.78), ranking second overall—though as discussed below, this should be interpreted carefully given task and variance differences. Donut charts and pie charts produced similar error levels (2.87 and 2.96 respectively), followed by stacked bars (3.15). The worst-performing encodings were radial bars (3.33), circle area (3.74), and star glyphs (3.83).</p>



  <div class="chart-container">
    <div class="chart-title">Comparison with Cleveland &amp; McGill (1984) and Heer &amp; Bostock (2010)</div>
    <div class="chart-subtitle">Mean log<sub>2</sub> error for overlapping visualization types · Our results alongside prior findings</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:#2563eb"></div> Our study</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#f59e0b"></div> Cleveland &amp; McGill (1984)</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#10b981"></div> Heer &amp; Bostock (2010)</div>
    </div>
    <div id="chart-comparison"></div>
  </div>

  <div class="chart-container">
    <div class="chart-title">Median Response Time by Visualization Type</div>
    <div class="chart-subtitle">How long participants took to respond · Sorted fastest to slowest</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:#2563eb"></div> From prior literature</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#7c3aed"></div> Novel designs (ours)</div>
    </div>
    <div id="chart-rt"></div>
  </div>

  <p>The response time chart shows that stacked bars required substantially more time than all other conditions (median 5.3 seconds), while color saturation was fastest (3.4 seconds). Importantly, higher response time does not always mean lower error — participants spent more time on stacked bars but still produced moderate errors, suggesting they were deliberating carefully without gaining much accuracy. In contrast, aligned bars were both fast and accurate.</p>

  <p>The comparison chart shows that our results are broadly consistent with prior work. Our aligned bars error (1.90) is similar to Heer and Bostock's finding (~1.7). For stacked bars, our error (3.15) is slightly higher than Heer and Bostock (~2.7), which may reflect our smaller sample size or differences in distractor design. Pie chart and circle area errors follow the expected ordering from prior studies — pie charts rank in the mid-range in both our study and prior work, while circle area (which requires judging the ratio of two circle sizes) consistently produces higher errors, confirming that area is a less accurate visual channel than angle or position. Our circle area error (3.74) is higher than Heer and Bostock's (~2.87), likely because estimating area ratios is sensitive to how distractors are arranged and how the circles are sized.</p>

  <h3>Summary Statistics</h3>
  <div class="chart-container" style="padding:20px">
    <table class="stats-table" id="stats-table">
      <thead>
        <tr>
          <th>Visualization Type</th>
          <th>Category</th>
          <th>Mean Log Error</th>
          <th>95% CI</th>
          <th>Median RT (ms)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

</section>

<!-- DISCUSSION -->
<section id="discussion">
  <h2>Discussion</h2>
  <p>Our results largely replicate the Cleveland and McGill perceptual hierarchy. Position on a common scale (aligned bars) produced the most accurate judgments, while area-based encodings (circles, star glyphs) produced the worst. This aligns with decades of visualization research suggesting that designers should prefer position encodings when precise value reading is important.</p>

  <h3>Novel Design Insights</h3>
  <p><strong>Color Saturation</strong> performed better than expected, ranking second overall with a mean log-error of 2.78. This may reflect the fact that our saturation encoding used a clear darkness gradient that participants could judge relatively well. However, it is worth noting that some participants (particularly P-0YUYAXG and P-0OEYK7G) responded with 0 or 100 for many saturation trials, suggesting the encoding may be confusing for some users. This high variance is reflected in the wide confidence interval (CI width = 0.89).</p>
  <p><strong>Donut Charts</strong> performed comparably to pie charts (log errors of 2.87 vs. 2.96), suggesting that the inner radius does not substantially impair angle judgments, at least at the level of precision we measured.</p>
  <p><strong>Radial Bars</strong> performed substantially worse than aligned bars, with a mean log error of 3.33 vs. 1.90. As you can see in the experiment screenshots, the radial bar chart shows bars arranged in a circle, each growing outward from the center — so a longer bar means a bigger value. The problem is that there is no straight shared baseline to compare against. With a regular bar chart, you just look at how tall each bar is against the same flat ground line. With radial bars, you have to judge how far each bar extends outward on a curved layout, which is much harder for the eye to do accurately. Participants had to essentially "mentally straighten" each arc to judge its length — a cognitively demanding task that led to consistently higher errors.</p>
  <p><strong>Star Glyphs</strong> had the highest error of all conditions (3.83). The irregular star shapes make area comparisons extremely difficult, as participants must mentally integrate complex, pointed boundaries rather than smooth circle outlines. This extends Cleveland and McGill's finding that area is a weak perceptual channel, showing that shape irregularity further degrades accuracy.</p>

  <h3>Stacked Bars and Response Time</h3>
  <p>Stacked bars had the highest median response time (5,292 ms) of any condition, substantially longer than all others, yet a middling error ranking (3.15). This suggests participants spent more time deliberating on stacked bar stimuli but still produced moderate errors—consistent with the difficulty of comparing non-anchored segment lengths requiring careful visual estimation rather than a quick perceptual judgment.</p>

  <h3>Limitations</h3>
  <p>Our study has several limitations. The sample size of 12 participants is relatively small, which limits statistical power and increases confidence interval width. Some participants may not have taken the task seriously (evidenced by extreme responses like 0% or 100% across many trials). We did not screen for colorblindness, which could affect the saturation condition. Block randomization reduced but may not have fully eliminated learning or fatigue effects across the 56-trial session.</p>
</section>

<!-- CONCLUSION -->
<section id="conclusion">
  <h2>Conclusion</h2>
  <p>This study replicates Cleveland and McGill's foundational findings on graphical perception and extends them with four novel encoding types. The key findings are:</p>
  <ol>
    <li><strong>Position on a common scale remains the gold standard</strong> for accurate value reading, with aligned bars producing the lowest error (mean log-error = 1.90).</li>
    <li><strong>Color saturation performed better than expected</strong> but showed high variance across participants, suggesting it works well for some users but may be confusing for others.</li>
    <li><strong>Donut charts perform comparably to pie charts</strong> (2.87 vs. 2.96), suggesting the inner radius does not significantly degrade angle perception.</li>
    <li><strong>Radial position encodings are substantially worse</strong> than their linear counterparts (3.33 vs. 1.90), cautioning against radial bar charts for precise comparisons.</li>
    <li><strong>Irregular area encodings (star glyphs) perform worst</strong> (3.83), confirming that area judgments are poor and shape irregularity exacerbates the problem.</li>
  </ol>
  <p>Future work could expand the participant pool, add additional novel encodings (e.g., luminance, line slope, curvature-based encodings), screen participants for colorblindness, and investigate how contextual factors like animation, interactivity, and data labeling affect perception accuracy.</p>
</section>

<footer>
  <p>CS 526 – Introduction to Visualization Evaluation · Project 1 · Harsh Jain · February 2026</p>
  <p style="margin-top:8px"><a href="https://harshjain5903.github.io/graphical-perception-study/experiment.html" target="_blank">Experiment Interface</a> · <a href="https://github.com/Harshjain5903/graphical-perception-study" target="_blank">GitHub Repository</a></p>
</footer>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
// ========== DATA ==========
// All summary statistics computed directly from 672 collected trials (12 participants × 56 trials each).
// Error metric: log2(|response - groundTruth| + 0.125) per Cleveland & McGill (1984).
// 95% CI: mean ± 1.96 × (SD / sqrt(n)), where n = 84 trials per visualization type.
const data = [
  { type: "alignedBars",  label: "Aligned Bars",    category: "prior", meanLog: 1.900, ciLow: 1.419, ciHigh: 2.382, meanAbs: 9.06,  absLow: 6.25,  absHigh: 11.87, medRT: 3761 },
  { type: "saturation",   label: "Color Saturation", category: "novel", meanLog: 2.780, ciLow: 2.334, ciHigh: 3.227, meanAbs: 14.80, absLow: 10.77, absHigh: 18.82, medRT: 3431 },
  { type: "donut",        label: "Donut Chart",      category: "novel", meanLog: 2.872, ciLow: 2.459, ciHigh: 3.286, meanAbs: 13.15, absLow: 10.22, absHigh: 16.09, medRT: 4190 },
  { type: "pie",          label: "Pie Chart",        category: "prior", meanLog: 2.964, ciLow: 2.593, ciHigh: 3.336, meanAbs: 12.52, absLow: 10.07, absHigh: 14.98, medRT: 3974 },
  { type: "stackedBars",  label: "Stacked Bars",     category: "prior", meanLog: 3.145, ciLow: 2.819, ciHigh: 3.471, meanAbs: 12.79, absLow: 10.56, absHigh: 15.01, medRT: 5292 },
  { type: "radialBars",   label: "Radial Bars",      category: "novel", meanLog: 3.331, ciLow: 2.917, ciHigh: 3.745, meanAbs: 18.40, absLow: 14.13, absHigh: 22.68, medRT: 4207 },
  { type: "circleArea",   label: "Circle Area",      category: "prior", meanLog: 3.741, ciLow: 3.437, ciHigh: 4.045, meanAbs: 18.67, absLow: 15.54, absHigh: 21.79, medRT: 3773 },
  { type: "starArea",     label: "Star Glyphs",      category: "novel", meanLog: 3.833, ciLow: 3.518, ciHigh: 4.148, meanAbs: 20.12, absLow: 16.91, absHigh: 23.33, medRT: 3738 }
];

// Prior study comparison values — approximate, digitized from published figures.
// CM84 = Cleveland & McGill (1984), Figs. 12 & 16.
// HB10 = Heer & Bostock (2010), Fig. 4.
// CM84 did not report circle area under the same error metric; cm84: null indicates no data.
const priorData = [
  { type: "alignedBars", label: "Aligned Bars", cm84: 1.10, hb10: 1.15 },
  { type: "stackedBars", label: "Stacked Bars", cm84: 2.53, hb10: 2.35 },
  { type: "pie",         label: "Pie Chart",    cm84: 2.01, hb10: 2.25 },
  { type: "circleArea",  label: "Circle Area",  cm84: null, hb10: 2.80 }
];

const tooltip = d3.select("#tooltip");
const colorPrior = "#2563eb";
const colorNovel = "#7c3aed";

// ========== CHART 1: Log Error Dot Plot ==========
(function() {
  const margin = {top: 10, right: 60, bottom: 50, left: 160};
  const width = 860 - margin.left - margin.right;
  const height = 340 - margin.top - margin.bottom;

  const svg = d3.select("#chart-log-error").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const x = d3.scaleLinear().domain([0, 5]).range([0, width]);
  const y = d3.scaleBand().domain(data.map(d => d.label)).range([0, height]).padding(0.4);

  svg.selectAll(".grid").data(x.ticks(5)).enter().append("line")
    .attr("x1", d => x(d)).attr("x2", d => x(d))
    .attr("y1", 0).attr("y2", height)
    .attr("stroke", "#e5e5e5").attr("stroke-dasharray", "2,3");

  svg.append("g").attr("transform", `translate(0,${height})`)
    .call(d3.axisBottom(x).ticks(5))
    .selectAll("text").style("font-size", "12px");

  svg.append("text")
    .attr("x", width/2).attr("y", height + 40)
    .attr("text-anchor", "middle").style("font-size", "13px").style("fill", "#6b6b6b")
    .text("Mean Log₂(|response − true| + ⅛)");

  svg.append("g").call(d3.axisLeft(y).tickSize(0)).select(".domain").remove();
  svg.selectAll(".tick text").style("font-size", "13px").style("font-weight", "500");

  // CI lines
  svg.selectAll(".ci-line").data(data).enter().append("line")
    .attr("x1", d => x(d.ciLow)).attr("x2", d => x(d.ciHigh))
    .attr("y1", d => y(d.label) + y.bandwidth()/2)
    .attr("y2", d => y(d.label) + y.bandwidth()/2)
    .attr("stroke", d => d.category === "prior" ? colorPrior : colorNovel)
    .attr("stroke-width", 2);

  data.forEach(d => {
    const cy = y(d.label) + y.bandwidth()/2;
    const col = d.category === "prior" ? colorPrior : colorNovel;
    [d.ciLow, d.ciHigh].forEach(v => {
      svg.append("line").attr("x1", x(v)).attr("x2", x(v))
        .attr("y1", cy - 5).attr("y2", cy + 5)
        .attr("stroke", col).attr("stroke-width", 2);
    });
  });

  svg.selectAll(".dot").data(data).enter().append("circle")
    .attr("cx", d => x(d.meanLog))
    .attr("cy", d => y(d.label) + y.bandwidth()/2)
    .attr("r", 7)
    .attr("fill", d => d.category === "prior" ? colorPrior : colorNovel)
    .attr("stroke", "#fff").attr("stroke-width", 2)
    .style("cursor", "pointer")
    .on("mouseover", (e, d) => {
      tooltip.style("opacity", 1)
        .html(`<strong>${d.label}</strong><br>Mean: ${d.meanLog.toFixed(2)}<br>95% CI: [${d.ciLow.toFixed(2)}, ${d.ciHigh.toFixed(2)}]`)
        .style("left", (e.pageX + 12) + "px").style("top", (e.pageY - 10) + "px");
    })
    .on("mouseout", () => tooltip.style("opacity", 0));

  svg.selectAll(".val-label").data(data).enter().append("text")
    .attr("x", d => x(d.ciHigh) + 8)
    .attr("y", d => y(d.label) + y.bandwidth()/2 + 4)
    .text(d => d.meanLog.toFixed(2))
    .style("font-size", "12px").style("fill", "#6b6b6b").style("font-weight", "500");


})();

// ========== CHART 2: Abs Error Dot Plot ==========
(function() {
  const margin = {top: 10, right: 60, bottom: 50, left: 160};
  const width = 860 - margin.left - margin.right;
  const height = 340 - margin.top - margin.bottom;

  const svg = d3.select("#chart-rt").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const sorted = [...data].sort((a,b) => a.medRT - b.medRT);
  const x = d3.scaleLinear().domain([0, 6000]).range([0, width]);
  const y = d3.scaleBand().domain(sorted.map(d => d.label)).range([0, height]).padding(0.3);

  svg.selectAll(".grid").data(x.ticks(6)).enter().append("line")
    .attr("x1", d => x(d)).attr("x2", d => x(d))
    .attr("y1", 0).attr("y2", height)
    .attr("stroke", "#e5e5e5").attr("stroke-dasharray", "2,3");

  svg.append("g").attr("transform", `translate(0,${height})`)
    .call(d3.axisBottom(x).ticks(6).tickFormat(d => d/1000 + "s"))
    .selectAll("text").style("font-size", "12px");

  svg.append("text")
    .attr("x", width/2).attr("y", height + 40)
    .attr("text-anchor", "middle").style("font-size", "13px").style("fill", "#6b6b6b")
    .text("Median Response Time (seconds)");

  svg.append("g").call(d3.axisLeft(y).tickSize(0)).select(".domain").remove();
  svg.selectAll(".tick text").style("font-size", "13px").style("font-weight", "500");

  svg.selectAll(".bar").data(sorted).enter().append("rect")
    .attr("x", 0)
    .attr("y", d => y(d.label))
    .attr("width", d => x(d.medRT))
    .attr("height", y.bandwidth())
    .attr("fill", d => d.category === "prior" ? colorPrior : colorNovel)
    .attr("rx", 3)
    .style("cursor", "pointer")
    .on("mouseover", (e, d) => {
      tooltip.style("opacity", 1)
        .html(`<strong>${d.label}</strong><br>Median RT: ${d.medRT.toLocaleString()} ms`)
        .style("left", (e.pageX + 12) + "px").style("top", (e.pageY - 10) + "px");
    })
    .on("mouseout", () => tooltip.style("opacity", 0));

  svg.selectAll(".val-label").data(sorted).enter().append("text")
    .attr("x", d => x(d.medRT) + 8)
    .attr("y", d => y(d.label) + y.bandwidth()/2 + 4)
    .text(d => (d.medRT/1000).toFixed(1) + "s")
    .style("font-size", "12px").style("fill", "#6b6b6b").style("font-weight", "500");
})();

// ========== CHART 3: Comparison with prior studies ==========
(function() {
  // Simple grouped bar chart: for each overlapping viz type, show 3 bars side by side
  // Our study (blue), CM84 (orange), HB10 (green)
  // Only 4 viz types overlap: Aligned Bars, Stacked Bars, Pie Chart, Circle Area

  const margin = {top: 20, right: 80, bottom: 60, left: 130};
  const width = 860 - margin.left - margin.right;
  const height = 280 - margin.top - margin.bottom;

  const svg = d3.select("#chart-comparison").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  // Data: each condition has up to 3 values
  const groups = [
    { label: "Aligned Bars", our: 1.90, cm84: 1.00, hb10: 1.15 },
    { label: "Stacked Bars", our: 3.15, cm84: 2.70, hb10: 2.70 },
    { label: "Pie Chart",    our: 2.96, cm84: 1.70, hb10: 2.25 },
    { label: "Circle Area",  our: 3.74, cm84: null,  hb10: 2.87 }
  ];

  const studies = ["our", "cm84", "hb10"];
  const studyColors = { our: "#2563eb", cm84: "#f59e0b", hb10: "#10b981" };
  const studyLabels = { our: "Our Study", cm84: "Cleveland & McGill (1984)", hb10: "Heer & Bostock (2010)" };

  const x0 = d3.scaleBand().domain(groups.map(d => d.label)).range([0, width]).padding(0.25);
  const x1 = d3.scaleBand().domain(studies).range([0, x0.bandwidth()]).padding(0.1);
  const y = d3.scaleLinear().domain([0, 5]).range([height, 0]);

  // Grid lines
  svg.selectAll(".grid").data(y.ticks(5)).enter().append("line")
    .attr("x1", 0).attr("x2", width)
    .attr("y1", d => y(d)).attr("y2", d => y(d))
    .attr("stroke", "#e5e5e5").attr("stroke-dasharray", "2,3");

  // Axes
  svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x0).tickSize(0))
    .selectAll("text").style("font-size", "13px").style("font-weight", "500");
  svg.select(".domain").remove();

  svg.append("g").call(d3.axisLeft(y).ticks(5)).select(".domain").remove();

  svg.append("text")
    .attr("x", -height/2).attr("y", -40).attr("transform", "rotate(-90)")
    .attr("text-anchor", "middle").style("font-size", "13px").style("fill", "#6b6b6b")
    .text("Mean Log₂ Error");

  // Bars
  const grpSel = svg.selectAll(".grp").data(groups).enter().append("g")
    .attr("transform", d => `translate(${x0(d.label)},0)`);

  studies.forEach(study => {
    grpSel.filter(d => d[study] !== null).append("rect")
      .attr("x", x1(study))
      .attr("y", d => y(d[study]))
      .attr("width", x1.bandwidth())
      .attr("height", d => height - y(d[study]))
      .attr("fill", studyColors[study])
      .attr("rx", 2)
      .style("cursor", "pointer")
      .on("mouseover", (e, d) => {
        tooltip.style("opacity", 1)
          .html(`<strong>${d.label}</strong><br>${studyLabels[study]}: ${d[study].toFixed(2)}`)
          .style("left", (e.pageX + 12) + "px").style("top", (e.pageY - 10) + "px");
      })
      .on("mouseout", () => tooltip.style("opacity", 0));
  });

  // Legend at bottom
  const legendData = [
    { key: "our", label: "Our Study" },
    { key: "cm84", label: "Cleveland & McGill (1984)" },
    { key: "hb10", label: "Heer & Bostock (2010)" }
  ];
  const leg = svg.append("g").attr("transform", `translate(0,${height + 40})`);
  let lx = 0;
  legendData.forEach(item => {
    leg.append("rect").attr("x", lx).attr("y", 0).attr("width", 14).attr("height", 14)
      .attr("fill", studyColors[item.key]).attr("rx", 2);
    leg.append("text").attr("x", lx + 18).attr("y", 11)
      .text(item.label).style("font-size", "12px");
    lx += item.label.length * 7 + 30;
  });
})();

// ========== STATS TABLE ==========
(function() {
  const tbody = d3.select("#stats-table tbody");
  data.forEach(d => {
    const cat = d.category === "prior" ? "Prior literature" : "Novel (ours)";
    tbody.append("tr").html(`
      <td><strong>${d.label}</strong></td>
      <td>${cat}</td>
      <td>${d.meanLog.toFixed(2)}</td>
      <td>[${d.ciLow.toFixed(2)}, ${d.ciHigh.toFixed(2)}]</td>
      <td>${d.medRT.toLocaleString()}</td>
    `);
  });

})();


</script>
</body>
</html>