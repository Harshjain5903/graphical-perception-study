<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CS 526 – Graphical Perception Experiment</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root{
      --bg:#f6f6f6; --card:#fff; --text:#222; --muted:#666;
      --accent:#1f77b4; --highlight:#d62728; --border:#ddd;
    }
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:920px;margin:0 auto;padding:22px;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:18px;box-shadow:0 1px 2px rgba(0,0,0,0.04);}
    h1{font-size:20px;margin:0 0 10px;}
    h2{font-size:16px;margin:16px 0 10px;}
    p,li{line-height:1.45;}
    .muted{color:var(--muted);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    button{padding:10px 14px;border:1px solid var(--border);border-radius:8px;background:var(--accent);color:#fff;font-size:14px;cursor:pointer;}
    button:disabled{opacity:.6;cursor:not-allowed;}
    .topbar{display:flex;justify-content:space-between;align-items:baseline;gap:12px;flex-wrap:wrap;margin-bottom:10px;}
    #viz{display:flex;justify-content:center;align-items:center;margin:14px 0 12px;min-height:420px;}
    #prompt{font-size:16px;font-weight:700;text-align:center;margin:0;}
    .sliderRow{display:grid;grid-template-columns:1fr;gap:8px;margin-top:14px;}
    #sliderValue{font-size:18px;font-weight:700;text-align:center;color:var(--accent);}
    input[type="range"]{width:100%;}
    .hr{height:1px;background:var(--border);margin:14px 0;}
    .tag{display:inline-block;padding:3px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;color:var(--muted);background:#fafafa;}
    .contactBox{
      margin-top:12px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:10px;
      background:#fafafa;
    }
    .contactBox b{color:#111;}
    .contactBox a{color:var(--accent);text-decoration:none;}
    .contactBox a:hover{text-decoration:underline;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card" id="screenStart">
      <h1>CS 526 – Graphical Perception Study</h1>

      <p class="muted">
        You will see one visualization at a time. Two data values will be highlighted.
        Your task: estimate <b>what percentage the lower highlighted value is of the higher highlighted value</b>
        based on <b>how that visualization encodes value</b> (length, area, angle, color intensity, etc.).
      </p>

      <h2>Instructions</h2>
      <ul>
        <li>Look for the two highlighted marks (outlined clearly).</li>
        <li>Use the slider to enter your percentage estimate (0–100%).</li>
        <li>Click <b>Next</b> to continue.</li>
        <li>At the end, download your data as one CSV file.</li>
      </ul>

      <div class="hr"></div>

      <div class="row">
        <button id="btnStart">Start</button>
        <span class="tag" id="pidTag" style="display:none;">Participant: —</span>
      </div>

      <p class="muted" style="margin-top:10px;">
        Time: ~10–15 minutes (8 blocks × 7 trials = 56 trials).
      </p>
    </div>

    <div class="card" id="screenTask" style="display:none;">
      <div class="topbar">
        <div>
          <span class="tag" id="progressTag">Trial 1 / 56</span>
          <span class="tag" id="blockTag">Block: —</span>
          <span class="tag" id="vizTag">Viz: —</span>
          <span class="tag" id="pidTagTop">Participant: —</span>
        </div>
        <div class="muted" id="hintText">Two highlighted values are outlined.</div>
      </div>

      <p id="prompt">—</p>

      <div id="viz"></div>

      <div class="sliderRow">
        <div id="sliderValue">50%</div>
        <input id="slider" type="range" min="0" max="100" value="50" step="1" />
        <button id="btnNext">Next</button>
      </div>
    </div>

    <div class="card" id="screenDone" style="display:none;">
      <h1>Done</h1>
      <p class="muted">
        Thank you for participating. Click the button to download your CSV.
      </p>

      <button id="btnDownload">Download CSV</button>

      <div class="contactBox">
        <div class="muted" style="margin-bottom:6px;">
          Please send your downloaded CSV file to:
        </div>
        <div>
          <b>Email:</b> <a href="mailto:hjain29@uic.edu">hjain29@uic.edu</a>
        </div>
        <div style="margin-top:6px;">
          <b>WhatsApp:</b> <a href="https://wa.me/17739091298" target="_blank" rel="noopener">+1 773 909 1298</a>
        </div>
        <div class="muted" style="margin-top:10px;">
          Thank you for taking the CS 526 graphical perception study.
        </div>
      </div>
    </div>
  </div>

<script>
/* --------------------------- Study design --------------------------- */

const VIZ_TYPES = [
  { id: "alignedBars",   label: "Aligned Bars (position/common scale)",         source: "Cleveland & McGill" },
  { id: "stackedBars",   label: "Stacked Bars (position/non-aligned)",          source: "Cleveland & McGill" },
  { id: "pie",           label: "Pie Chart (angle)",                            source: "Cleveland & McGill" },
  { id: "circleArea",    label: "Circle Area (area)",                           source: "Heer & Bostock" },
  { id: "donut",         label: "Donut Chart (angle + inner radius)",           source: "Novel" },
  { id: "saturation",    label: "Color Saturation (intensity encoding)",        source: "Novel" },
  { id: "radialBars",    label: "Radial Bars (position on circular axis)",      source: "Novel" },
  { id: "starArea",      label: "Star Glyphs (irregular shape area encoding)",  source: "Novel" }
];

const RATIOS = [14, 25, 38, 50, 62, 75, 86];

const DISTRACTOR_COUNT = 6;
const DISTRACTOR_MIN = 15;
const DISTRACTOR_MAX = 95;

/* Highlight styling (reduced thickness to avoid “too much” halo) */
const HALO_WHITE_W = 6;
const HALO_RED_W   = 3;

/* --------------------------- UI references -------------------------- */

const screenStart = document.getElementById("screenStart");
const screenTask  = document.getElementById("screenTask");
const screenDone  = document.getElementById("screenDone");

const btnStart = document.getElementById("btnStart");
const btnNext = document.getElementById("btnNext");
const btnDownload = document.getElementById("btnDownload");

const slider = document.getElementById("slider");
const sliderValue = document.getElementById("sliderValue");

const progressTag = document.getElementById("progressTag");
const blockTag = document.getElementById("blockTag");
const vizTag = document.getElementById("vizTag");

const pidTag = document.getElementById("pidTag");
const pidTagTop = document.getElementById("pidTagTop");

const promptEl = document.getElementById("prompt");
const hintText = document.getElementById("hintText");

/* --------------------------- Experiment state ----------------------- */

let participantId = "";
let trials = [];
let trialIndex = 0;
let trialStartMs = 0;
let results = [];

/* --------------------------- Helpers -------------------------------- */

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function randInRange(min, max) {
  return min + Math.random() * (max - min);
}

function makeDistractors() {
  const vals = [];
  while (vals.length < DISTRACTOR_COUNT) {
    const v = Math.round(randInRange(DISTRACTOR_MIN, DISTRACTOR_MAX));
    vals.push(v);
  }
  return vals;
}

function clampInt(x, lo, hi) {
  const n = Number(x);
  if (!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, Math.round(n)));
}

function csvEscape(value) {
  const s = String(value);
  if (s.includes(",") || s.includes('"') || s.includes("\n")) {
    return '"' + s.replaceAll('"', '""') + '"';
  }
  return s;
}

function isTarget(i, targetIdx) {
  return i === targetIdx[0] || i === targetIdx[1];
}

/* ------------------ Prompt & hint text (saturation + star) ---------- */

function getPromptForViz(vizId) {
  if (vizId === "saturation") {
    return "What percentage is the LIGHTER highlighted value of the DARKER highlighted value? (Darker = larger)";
  }
  return "What percentage is the smaller highlighted value of the larger highlighted value?";
}

function getHintForViz(vizId) {
  if (vizId === "saturation") {
    return "Value is encoded by color intensity: darker = larger, lighter = smaller. Targets are outlined.";
  }
  if (vizId === "starArea") {
    return "Value is encoded by filled star area: larger filled star = larger value. Targets are outlined.";
  }
  return "Two highlighted values are outlined.";
}

/* --------------------------- Participant ID ------------------------- */

function generateParticipantId() {
  const bytes = new Uint8Array(4);
  crypto.getRandomValues(bytes);
  let num = 0;
  for (const b of bytes) num = (num * 256) + b;
  const token = num.toString(36).toUpperCase().padStart(7, "0").slice(-7);
  return `P-${token}`;
}

function getUniqueParticipantId() {
  const key = "cs526_used_participant_ids";
  let used = [];
  try {
    used = JSON.parse(localStorage.getItem(key) || "[]");
    if (!Array.isArray(used)) used = [];
  } catch {
    used = [];
  }

  let pid = generateParticipantId();
  let tries = 0;
  while (used.includes(pid) && tries < 20) {
    pid = generateParticipantId();
    tries += 1;
  }

  used.push(pid);
  if (used.length > 1000) used = used.slice(-1000);
  localStorage.setItem(key, JSON.stringify(used));
  return pid;
}

/* --------------------------- Build trial list (blocks) -------------- */

function buildTrials() {
  const blockOrder = shuffle(VIZ_TYPES.map(v => v.id));

  const all = [];
  blockOrder.forEach((vizId, bIdx) => {
    const ratioOrder = shuffle(RATIOS);
    ratioOrder.forEach((ratioPct, tIdxInBlock) => {
      all.push({
        vizId,
        blockNumber: bIdx + 1,
        trialInBlock: tIdxInBlock + 1,
        groundTruthPct: ratioPct
      });
    });
  });

  return all;
}

/* --------------------------- Data generation per trial -------------- */

function makeTrialData(groundTruthPct) {
  const larger = 100;
  const smaller = groundTruthPct;

  const distractors = makeDistractors();
  const values = shuffle([larger, smaller, ...distractors]);

  const idxL = values.indexOf(larger);
  const idxS = values.indexOf(smaller);

  return { larger, smaller, values, targetIdx: [idxL, idxS] };
}

/* --------------------------- Rendering helpers ---------------------- */

function clearViz() {
  d3.select("#viz").html("");
}

function makeSvg(width, height) {
  const svg = d3.select("#viz")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const defs = svg.append("defs");
  const f = defs.append("filter")
    .attr("id", "haloShadow")
    .attr("x", "-30%").attr("y", "-30%")
    .attr("width", "160%").attr("height", "160%");
  f.append("feDropShadow")
    .attr("dx", 0).attr("dy", 1)
    .attr("stdDeviation", 0.7)
    .attr("flood-color", "#000")
    .attr("flood-opacity", 0.22);

  return svg;
}

function highlightColor() {
  return getComputedStyle(document.documentElement).getPropertyValue("--highlight").trim() || "#d62728";
}

/* Stroke-only overlays so the data marks themselves are unchanged */
function addHaloRect(g, x, y, w, h, rx=2, ry=2) {
  const common = {
    "pointer-events": "none",
    "vector-effect": "non-scaling-stroke"
  };

  g.append("rect")
    .attr("x", x).attr("y", y).attr("width", w).attr("height", h)
    .attr("rx", rx).attr("ry", ry)
    .attr("fill", "none")
    .attr("stroke", "#ffffff")
    .attr("stroke-width", HALO_WHITE_W)
    .attr("filter", "url(#haloShadow)")
    .attr(common);

  g.append("rect")
    .attr("x", x).attr("y", y).attr("width", w).attr("height", h)
    .attr("rx", rx).attr("ry", ry)
    .attr("fill", "none")
    .attr("stroke", highlightColor())
    .attr("stroke-width", HALO_RED_W)
    .attr(common);
}

function addHaloPath(g, d) {
  const common = {
    "pointer-events": "none",
    "vector-effect": "non-scaling-stroke"
  };

  g.append("path")
    .attr("d", d)
    .attr("fill", "none")
    .attr("stroke", "#ffffff")
    .attr("stroke-width", HALO_WHITE_W)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("filter", "url(#haloShadow)")
    .attr(common);

  g.append("path")
    .attr("d", d)
    .attr("fill", "none")
    .attr("stroke", highlightColor())
    .attr("stroke-width", HALO_RED_W)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr(common);
}

/* --------------------------- Visualizations ------------------------- */

/* ---- 1) Aligned bars ---- */
function drawAlignedBars(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const margin = { top: 20, right: 20, bottom: 30, left: 30 };
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(d3.range(data.values.length)).range([0, innerW]).padding(0.2);
  const y = d3.scaleLinear().domain([0, d3.max(data.values)]).nice().range([innerH, 0]);

  const bars = g.selectAll("rect")
    .data(data.values)
    .enter()
    .append("rect")
    .attr("x", (_, i) => x(i))
    .attr("y", d => y(d))
    .attr("width", x.bandwidth())
    .attr("height", d => innerH - y(d))
    .attr("fill", "#1f77b4")
    .attr("opacity", 0.85);

  bars.each(function(_, i) {
    if (!isTarget(i, data.targetIdx)) return;
    const r = d3.select(this);
    addHaloRect(g, +r.attr("x"), +r.attr("y"), +r.attr("width"), +r.attr("height"), 2, 2);
  });

  g.append("line")
    .attr("x1", 0).attr("x2", innerW)
    .attr("y1", innerH).attr("y2", innerH)
    .attr("stroke", "#bbb");
}

/* ---- 2) Stacked bars ---- */
function drawStackedBars(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const margin = { top: 20, right: 20, bottom: 20, left: 20 };

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  const total = d3.sum(data.values);
  const y = d3.scaleLinear().domain([0, total]).range([innerH, 0]);

  const barX = innerW * 0.35;
  const barW = innerW * 0.30;

  let cum = 0;
  data.values.forEach((v, i) => {
    const y0 = y(cum);
    const y1 = y(cum + v);

    g.append("rect")
      .attr("x", barX)
      .attr("y", y1)
      .attr("width", barW)
      .attr("height", y0 - y1)
      .attr("fill", "#ff7f0e")
      .attr("opacity", 0.85)
      .attr("stroke", "#fff")
      .attr("stroke-width", 1);

    if (isTarget(i, data.targetIdx)) {
      addHaloRect(g, barX, y1, barW, (y0 - y1), 2, 2);
    }

    cum += v;
  });
}

/* ---- 3) Pie / Donut ---- */
function drawPie(svg, data, isDonut) {
  const W = +svg.attr("width"), H = +svg.attr("height");

  const radius = Math.min(W, H) * 0.35;
  const innerR = isDonut ? radius * 0.45 : 0;

  const g = svg.append("g").attr("transform", `translate(${W/2},${H/2})`);

  const pie = d3.pie().value(d => d);
  const arcs = pie(data.values);

  const arc = d3.arc().innerRadius(innerR).outerRadius(radius);

  g.selectAll("path.slice")
    .data(arcs)
    .enter()
    .append("path")
    .attr("class", "slice")
    .attr("d", arc)
    .attr("fill", (_, i) => d3.schemeCategory10[i % 10])
    .attr("opacity", 0.9)
    .attr("stroke", "#fff")
    .attr("stroke-width", 2);

  arcs.forEach((a, i) => {
    if (!isTarget(i, data.targetIdx)) return;
    addHaloPath(g, arc(a));
  });
}

/* ---- 4) Circle Area ---- */
function drawCircleArea(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const margin = 30;

  const maxR = 58;
  const r = d3.scaleSqrt().domain([0, d3.max(data.values)]).range([0, maxR]);

  const cols = 4;
  const cellW = (W - 2 * margin) / cols;
  const cellH = (H - 2 * margin) / 2;

  const g = svg.append("g").attr("transform", `translate(${margin},${margin})`);

  g.selectAll("circle")
    .data(data.values)
    .enter()
    .append("circle")
    .attr("cx", (_, i) => (i % cols) * cellW + cellW / 2)
    .attr("cy", (_, i) => Math.floor(i / cols) * cellH + cellH / 2)
    .attr("r", d => r(d))
    .attr("fill", "#2ca02c")
    .attr("opacity", 0.55)
    .each(function(_, i){
      if (!isTarget(i, data.targetIdx)) return;
      const c = d3.select(this);
      const cx = +c.attr("cx"), cy = +c.attr("cy"), rr = +c.attr("r");
      const gg = g.append("g").attr("pointer-events","none");
      gg.append("circle").attr("cx", cx).attr("cy", cy).attr("r", rr)
        .attr("fill","none").attr("stroke","#fff").attr("stroke-width",HALO_WHITE_W)
        .attr("vector-effect","non-scaling-stroke")
        .attr("filter","url(#haloShadow)");
      gg.append("circle").attr("cx", cx).attr("cy", cy).attr("r", rr)
        .attr("fill","none").attr("stroke",highlightColor()).attr("stroke-width",HALO_RED_W)
        .attr("vector-effect","non-scaling-stroke");
    });
}

/* ---- 5) Saturation ---- */
function drawSaturation(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const margin = { top: 40, right: 20, bottom: 40, left: 20 };
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(d3.range(data.values.length)).range([0, innerW]).padding(0.2);
  const a = d3.scaleLinear().domain([0, d3.max(data.values)]).range([0.25, 1.0]);

  const rects = g.selectAll("rect")
    .data(data.values)
    .enter()
    .append("rect")
    .attr("x", (_, i) => x(i))
    .attr("y", innerH * 0.25)
    .attr("width", x.bandwidth())
    .attr("height", innerH * 0.50)
    .attr("fill", "#1f77b4")
    .attr("opacity", d => a(d));

  rects.each(function(_, i){
    if (!isTarget(i, data.targetIdx)) return;
    const r = d3.select(this);
    addHaloRect(g, +r.attr("x"), +r.attr("y"), +r.attr("width"), +r.attr("height"), 2, 2);
  });
}

/* ---- 6) Radial Bars ---- */
function drawRadialBars(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const g = svg.append("g").attr("transform", `translate(${W/2},${H/2})`);

  const n = data.values.length;
  const innerR = 35;
  const outerR = Math.min(W, H) * 0.40;

  const r = d3.scaleLinear().domain([0, d3.max(data.values)]).range([innerR, outerR]);
  const angle = d3.scaleBand().domain(d3.range(n)).range([0, Math.PI * 2]).padding(0.08);

  [25, 50, 75, 100].forEach(v => {
    g.append("circle").attr("r", r(v)).attr("fill", "none").attr("stroke", "#e3e3e3");
  });

  const arc = d3.arc();

  const paths = g.selectAll("path.bar")
    .data(data.values)
    .enter()
    .append("path")
    .attr("class", "bar")
    .attr("d", (d, i) => arc({
      innerRadius: innerR,
      outerRadius: r(d),
      startAngle: angle(i),
      endAngle: angle(i) + angle.bandwidth()
    }))
    .attr("fill", "#9467bd")
    .attr("opacity", 0.9)
    .attr("stroke", "#fff")
    .attr("stroke-width", 1.5);

  paths.each(function(_, i){
    if (!isTarget(i, data.targetIdx)) return;
    addHaloPath(g, d3.select(this).attr("d"));
  });

  g.append("circle").attr("r", 2.5).attr("fill", "#666");
}

/* ---- 7) Star Area ---- */
function starPath(cx, cy, outerR, innerR, points = 5) {
  let d = "";
  const step = Math.PI / points;
  for (let i = 0; i < 2 * points; i++) {
    const rr = (i % 2 === 0) ? outerR : innerR;
    const a = -Math.PI / 2 + i * step;
    const x = cx + rr * Math.cos(a);
    const y = cy + rr * Math.sin(a);
    d += (i === 0 ? "M" : "L") + x + "," + y;
  }
  return d + "Z";
}

function drawStarArea(svg, data) {
  const W = +svg.attr("width"), H = +svg.attr("height");
  const margin = 35;

  const maxOuter = 55;
  const r = d3.scaleSqrt().domain([0, d3.max(data.values)]).range([0, maxOuter]);

  const cols = 4;
  const cellW = (W - 2 * margin) / cols;
  const cellH = (H - 2 * margin) / 2;

  const g = svg.append("g").attr("transform", `translate(${margin},${margin})`);

  data.values.forEach((v, i) => {
    const cx = (i % cols) * cellW + cellW / 2;
    const cy = Math.floor(i / cols) * cellH + cellH / 2;

    const outerR = r(v);
    const innerR = outerR * 0.45;
    const d = starPath(cx, cy, outerR, innerR, 5);

    g.append("path")
      .attr("d", d)
      .attr("fill", "#17becf")
      .attr("opacity", 0.65);

    if (isTarget(i, data.targetIdx)) {
      addHaloPath(g, d);
    }
  });
}

/* --------------------------- Draw dispatcher ------------------------ */

function renderTrial(trial) {
  clearViz();

  const viz = VIZ_TYPES.find(v => v.id === trial.vizId);

  progressTag.textContent = `Trial ${trialIndex + 1} / ${trials.length}`;
  blockTag.textContent = `Block ${trial.blockNumber} / ${VIZ_TYPES.length}`;
  vizTag.textContent = viz ? viz.label : trial.vizId;

  promptEl.textContent = getPromptForViz(trial.vizId);
  hintText.textContent = getHintForViz(trial.vizId);

  slider.value = "50";
  sliderValue.textContent = "50%";

  const data = makeTrialData(trial.groundTruthPct);
  trial._data = data;

  const svg = makeSvg(700, 420);

  switch (trial.vizId) {
    case "alignedBars":  drawAlignedBars(svg, data); break;
    case "stackedBars":  drawStackedBars(svg, data); break;
    case "pie":          drawPie(svg, data, false); break;
    case "donut":        drawPie(svg, data, true); break;
    case "circleArea":   drawCircleArea(svg, data); break;
    case "saturation":   drawSaturation(svg, data); break;
    case "radialBars":   drawRadialBars(svg, data); break;
    case "starArea":     drawStarArea(svg, data); break;
    default:             drawAlignedBars(svg, data);
  }

  trialStartMs = Date.now();
}

/* --------------------------- Record result + advance ---------------- */

function recordAndAdvance() {
  btnNext.disabled = true;

  const trial = trials[trialIndex];
  const elapsedMs = Date.now() - trialStartMs;

  const responsePct = clampInt(slider.value, 0, 100);
  const groundTruthPct = trial.groundTruthPct;

  const viz = VIZ_TYPES.find(v => v.id === trial.vizId);

  results.push({
    participantId,
    trialNumber: trialIndex + 1,
    blockNumber: trial.blockNumber,
    trialInBlock: trial.trialInBlock,
    visualizationType: trial.vizId,
    visualizationLabel: viz ? viz.label : trial.vizId,
    groundTruthPct,
    responsePct,
    responseTimeMs: elapsedMs
  });

  trialIndex += 1;

  if (trialIndex < trials.length) {
    renderTrial(trials[trialIndex]);
    btnNext.disabled = false;
  } else {
    screenTask.style.display = "none";
    screenDone.style.display = "block";
  }
}

/* --------------------------- Download CSV --------------------------- */

function downloadCSV() {
  const headers = [
    "participantId","trialNumber","blockNumber","trialInBlock",
    "visualizationType","visualizationLabel",
    "groundTruthPct","responsePct","responseTimeMs"
  ];

  const lines = [];
  lines.push(headers.join(","));

  results.forEach(row => {
    const values = headers.map(h => csvEscape(row[h]));
    lines.push(values.join(","));
  });

  const csvText = lines.join("\n");
  const blob = new Blob([csvText], { type: "text/csv;charset=utf-8" });

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `cs526_graphical_perception_${participantId}_${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

/* --------------------------- Wire UI events ------------------------- */

slider.addEventListener("input", () => {
  sliderValue.textContent = `${slider.value}%`;
});

btnStart.addEventListener("click", () => {
  participantId = getUniqueParticipantId();

  pidTag.style.display = "inline-block";
  pidTag.textContent = `Participant: ${participantId}`;
  pidTagTop.textContent = `Participant: ${participantId}`;

  trials = buildTrials();
  trialIndex = 0;
  results = [];

  screenStart.style.display = "none";
  screenDone.style.display = "none";
  screenTask.style.display = "block";

  renderTrial(trials[trialIndex]);
  btnNext.disabled = false;
});

btnNext.addEventListener("click", recordAndAdvance);
btnDownload.addEventListener("click", downloadCSV);
</script>
</body>
</html>
